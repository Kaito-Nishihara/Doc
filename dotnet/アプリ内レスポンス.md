# アプリ内レスポンス設計ガイド（AppResultパターン）

---

## 1. 概要

本ドキュメントは、ASP.NET Core アプリケーションにおいて、  
**サービス層の処理結果（成功／失敗）を一貫して扱うためのレスポンス型設計例** をまとめたものです。

---

## 2. 目的とメリット


| 項目                                 | 説明                                                  |
| :----------------------------------- | :---------------------------------------------------- |
| 処理の成否を一元管理                 | `Succeeded` プロパティで成功/失敗を明示的に判定       |
| エラーメッセージの構造化             | `AppError` 型を通してエラーを統一形式で管理           |
| 汎用データ対応                       | `AppResult<T>` により任意の型のデータと一緒に返却可能 |
| コントローラー内レスポンス変換が容易 | `ActionResult<T>` に変換しやすい構造設計              |

- **サービス層メソッドの戻り値として `void` を使用しない** ことを目的として下記のようなResultメソッドを使用することを推奨する

```csharp
public class AppResult
{
    /// <summary>
    /// 処理が成功したかどうかを示す。
    /// </summary>
    public bool Succeeded { get; internal set; }

    /// <summary>
    /// 成功時に使用するシングルトンインスタンス。
    /// 毎回 new せずに共通インスタンスを返す用途で使用。
    /// </summary>
    internal static readonly AppResult _success = new()
    {
        Succeeded = true
    };

    /// <summary>
    /// 成功した結果を取得（メッセージなし）。
    /// </summary>
    public static AppResult Success => _success;

    /// <summary>
    /// 成功時のメッセージ（オプション）。
    /// </summary>
    public string? Message { get; internal set; }

    /// <summary>
    /// 結果を文字列として出力
    /// </summary>
    public override string ToString()
    {
        if (!Succeeded)
        {
            return $"Failed: {string.Join(", ", Errors)}";
        }

        return Message is not null ? $"Succeeded: {Message}" : "Succeeded";
    }

    /// <summary>
    /// 内部エラーリスト（外部からは IEnumerable として公開）。
    /// </summary>
    internal readonly List<AppError> _errors = new();

    /// <summary>
    /// エラー一覧（失敗時のみ有効）。
    /// </summary>
    public IEnumerable<AppError> Errors => _errors;

    /// <summary>
    /// 最初のエラーメッセージを取得（存在しない場合は null）。
    /// </summary>
    public string? FirstErrorMessage => _errors.FirstOrDefault()?.Message;


    /// <summary>
    /// 複数のエラーを伴う失敗結果を返す。
    /// </summary>
    public static AppResult Failed(params AppError[] errors)
    {
        var result = new AppResult { Succeeded = false };
        if (errors != null)
        {
            result._errors.AddRange(errors);
        }
        return result;
    }

    /// <summary>
    /// 単一のエラーを伴う失敗結果を返す。
    /// </summary>
    public static AppResult Failed(AppError error)
    {
        var result = new AppResult { Succeeded = false };
        if (error != null)
        {
            result._errors.Add(error);
        }
        return result;
    }

    /// <summary>
    /// 文字列からエラーを生成して失敗結果を返す（簡易版）。
    /// </summary>
    public static AppResult Failed(string error)
    {
        var result = new AppResult { Succeeded = false };
        if (error != null)
        {
            result._errors.Add(new AppError(error));
        }
        return result;
    }

    /// <summary>
    /// List<AppError> を使って失敗結果を返す。
    /// </summary>
    public static AppResult Failed(List<AppError>? errors)
    {
        var result = new AppResult { Succeeded = false };
        if (errors != null)
        {
            result._errors.AddRange(errors);
        }
        return result;
    }

    /// <summary>
    /// 成功しつつ、メッセージを伴う結果を返す。
    /// </summary>
    public static AppResult SuccessWithMessage(string message)
    {
        return new AppResult
        {
            Succeeded = true,
            Message = message
        };
    }

}

public class AppResult<T> : AppResult
{
    /// <summary>
    /// 成功時に返すデータ。
    /// </summary>
    public T? Data { get; private set; }

    /// <summary>
    /// データ付き成功結果を返す。
    /// </summary>
    public static AppResult<T> SuccessWithData(T data)
    {
        return new AppResult<T>
        {
            Succeeded = true,
            Data = data
        };
    }

    /// <summary>
    /// データ付き成功結果とメッセージを返す。
    /// </summary>
    public static AppResult<T> SuccessWithData(T data, string message)
    {
        return new AppResult<T>
        {
            Succeeded = true,
            Data = data,
            Message = message
        };
    }

    /// <summary>
    /// データ型付き失敗結果（1件のエラー）。
    /// </summary>
    public new static AppResult<T> Failed(AppError error)
    {
        var result = new AppResult<T> { Succeeded = false };
        if (error != null)
        {
            result._errors.Add(error);
        }
        return result;
    }

    /// <summary>
    /// データ型付き失敗結果（複数エラー）。
    /// </summary>
    public new static AppResult<T> Failed(params AppError[] errors)
    {
        var result = new AppResult<T> { Succeeded = false };
        if (errors != null)
        {
            result._errors.AddRange(errors);
        }
        return result;
    }

    /// <summary>
    /// 文字列からエラーを生成して失敗。
    /// </summary>
    public new static AppResult<T> Failed(string error)
    {
        var result = new AppResult<T> { Succeeded = false };
        if (error != null)
        {
            result._errors.Add(new AppError(error));
        }
        return result;
    }
}

```

## 3. 使用例

### 3.1 サービス層での使用例

#### ✅ 正常系（データなし）
```csharp
public async Task<AppResult> UpdateUserEmailAsync(Guid userId, string email)
{
    var user = await _userRepository.GetByIdAsync(userId);
    if (user == null)
        return AppResult.Failed("ユーザーが見つかりません");

    user.Email = email;
    await _userRepository.SaveChangesAsync();

    return AppResult.Success;
}
```

#### ✅ 正常系（データあり）
```csharp
public async Task<AppResult<UserDto>> CreateUserAsync(UserCreateDto dto)
{
    if (await _userRepository.ExistsByEmail(dto.Email))
        return AppResult<int>.Failed("既に同じメールアドレスが登録されています");

    var user = new User { Id = Guid.NewGuid(), Name = dto.Name, Email = dto.Email };
    await _userRepository.AddAsync(user);
    await _userRepository.SaveChangesAsync();

    return AppResult<int>.SuccessWithData(new UserDto(user), "ユーザーを登録しました");
}
```

### 3.2 コントローラー層での使用例

#### ✅ AppResult をもとに HTTP レスポンスを返す
```csharp
[HttpPut("{id}")]
public async Task<IActionResult> UpdateUser(Guid id, [FromBody] UserUpdateDto dto)
{
    var result = await _userService.UpdateUserAsync(id, dto);

    if (!result.Succeeded)
        return BadRequest(result.Errors); // 400 BadRequest としてエラーを返す

    return Ok(result.Message);
}
```

#### ✅ AppResult<T> をもとにデータを返す

```csharp
[HttpPost]
public async Task<IActionResult> Create([FromBody] UserCreateDto dto)
{
    var result = await _userService.CreateUserAsync(dto);

    if (!result.Succeeded)
        return BadRequest(result.Errors);

    return CreatedAtAction(nameof(GetById), new { id = result.Data.Id }, result.Data);
}
```


## 4. `void` / `Task` のみを戻り値に使うことによる問題点

サービス層で `void` や `Task` を使って処理結果を返さない場合、  
以下のような**実用上の問題**が発生します。

### ❌ パターン1：失敗を呼び出し元で検知できない
- 呼び出し元（Controllerなど）では 成功／失敗を判断できない
- nullチェックすら不要に見えるため バグの温床になる
```csharp
public async Task RegisterUserAsync(UserCreateDto dto)
{
    if (await _userRepository.ExistsByEmail(dto.Email))
    {
        // 何も返さない（例外も投げない）
        return;
    }

    await _userRepository.AddAsync(new User { ... });
    await _userRepository.SaveChangesAsync();
}
```

### ❌ パターン2：例外ベースの制御が乱発される
- 例外に依存するとテスト困難・スタックトレース過多になる

- コントローラー層で try-catch が乱立しやすい

- バリデーションエラーすら例外として扱われると UX が不自然になる
```csharp
public async Task RegisterUserAsync(UserCreateDto dto)
{
    if (await _userRepository.ExistsByEmail(dto.Email))
    {
        throw new Exception("既に登録されています");
    }
}
```

### ❌ パターン3：成功前提での実装になる
- `void` や `Task`（戻り値なし）を使うと、「**成功前提の設計になりやすい**」傾向がある
```csharp
public async Task UpdateStatusAsync(Guid id, string newStatus)
{
    var user = await _userRepository.GetByIdAsync(id);
    
    // user が null の場合でも処理が続いてしまう
    // 本来はこの前にNullチェックが必要
    user.Status = newStatus;

    await _userRepository.SaveChangesAsync();
}
```