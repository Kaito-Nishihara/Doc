# 単体テスト（Unit Test）開発ガイド

## 1. 概要

本ドキュメントは、ASP.NET Coreプロジェクトにおいて、  
**単体テスト（Unit Test）** を正しく、効率的に開発するための標準手順をまとめたものです。

単体テストは「個々のメソッドやクラスのロジック」を検証するものであり、  
外部システム（DB、APIなど）に依存しない設計を目指します。

---

## 2. 使用ライブラリ

| ライブラリ               | 用途                                               |
| :----------------------- | :------------------------------------------------- |
| xUnit                    | テストフレームワーク                               |
| Moq                      | 依存関係（リポジトリなど）をモック化するライブラリ |

## 3. テスト対象の前提
- 例：サービス層のメソッド単位をテスト
```csharp
public interface IUserService
{
    Task<UserDto?> GetByIdAsync(Guid id);
    Task<UserDto> CreateAsync(UserCreateDto dto);
}
```

## 4. テストプロジェクト構成
- クラス単位でファイルを分ける
- ファイル名は `[クラス名]Tests.cs` とする
```markdown
/Tests
  /Services
    UserServiceTests.cs
```

## 5. テストクラス基本構成
- `GetByIdAsync` メソッドがこのようになっている場合のテスト例を実装します。
```csharp
 public async Task<UserDto?> GetByIdAsync(Guid id)
{
    try
    {
        var user = await _userRepository.GetByIdAsync(id);
        if (user == null) return null;

        return new UserDto
        {
            Id = user.Id,
            Name = user.Name,
            Email = user.Email
        };
    }
    catch (Exception ex)
    {
        throw new ApplicationException("ユーザー取得中にエラーが発生しました。", ex);
    }
}
```

### 正常系テスト例
```csharp
[Fact]
public async Task GetByIdAsync_ユーザーを返す_IDに紐づくユーザーが存在する場合()
{
    // Arrange
    var userId = Guid.NewGuid();
    _mockRepo.Setup(r => r.GetByIdAsync(userId))
     .ReturnsAsync(new UserDto { Id = userId, Name = "テストユーザー", Email = "test@example.com" });

    // Act
    var result = await _service.GetByIdAsync(userId);

    // Assert
    Assert.NotNull(result);
    Assert.Equal("テストユーザー", result!.Name);
}

[Fact]
public async Task GetByIdAsync_Nullを返す_IDに紐づくユーザーが存在しない場合()
{
    // Arrange
    var userId = Guid.NewGuid();
    _mockRepo.Setup(r => r.GetByIdAsync(userId))
             .ReturnsAsync((UserDto?)null); // ← 存在しない想定

    // Act
    var result = await _service.GetByIdAsync(userId);

    // Assert
    Assert.Null(result);
}
```

### 異常系テスト例
- 想定外の動作が発生する可能性がある場合だけ異常系のコードを実装すること

```csharp
[Fact]
public async Task GetByIdAsync_ApplicationExceptionをスローする_リポジトリエラー発生時()
{
    // Arrange
    var userId = Guid.NewGuid();
    _mockRepo.Setup(r => r.GetByIdAsync(userId))
             .ThrowsAsync(new Exception("DB接続エラー"));

    // Act & Assert
    var exception = await Assert.ThrowsAsync<ApplicationException>(() => _service.GetByIdAsync(userId));

    Assert.Equal("ユーザー取得中にエラーが発生しました。", exception.Message);
    Assert.NotNull(exception.InnerException);
    Assert.Equal("DB接続エラー", exception.InnerException!.Message);
}
```

#### 判断ポイント

- 単体テストにおいて、異常系テストを書くかどうかは、サービス層の設計に応じて判断する。

| サービス層の挙動                         | このテストいる？ | 理由                                                                                 |
| :--------------------------------------- | :--------------- | :----------------------------------------------------------------------------------- |
| try-catchして、例えばログ出力している    | 必要             | catch内でログ出力や別の処理をしている場合、その振る舞いを保証するため                |
| 例外を握りつぶして独自例外に変換している | 必要             | 独自例外への変換や、例外メッセージの加工が設計に含まれているため、その内容を検証する |
| 何もせずそのまま上に流している           | 不要             | .NETの標準例外伝播の動作に依存しており、アプリケーション独自の動きがないため         |
